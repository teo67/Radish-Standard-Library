h {
    ;Get the length of an array. Note that this will count any additional object parameters that have been added to the array.;
    d length {
        h {
            h ARRLEN(this)
            h 0 + 0
        }
    }
    ;Append a value to the end of an array. arr.push(x) is equivalent to arr[arr.length] p x, and both are acceptable statements.
    @input@The value to be pushed to the given array.@;
    d push p t(input) {
        this[this.length] p input
        h this
    }
    ;Remove and harvest the last value of an array. arr.pop() is equivalent to arr.remove(arr.length - 1), and both are acceptable statements.;
    d pop p t() {
        d len p this.length
        if(len < 1) {
            throw "Cannot pop from an empty array!"
        }
        h this.delete(len - 1)
    }
    ;Find the 0-based index of an item within an array. The index is found using a standard Radish equivalence check, which means that objects and arrays must be stored at the same reference to be equal.
Note: indexOf will return -1 if no item is found.
    @item@The item in the array to be searched for.@;
    d indexOf p t(item) {
        for(d i p 0, i < this.length, i++) {
            if(this[i] == item) {
                h i
            }
        }
        h -1
    }
    ;Check whether an array contains an item via Array.indexOf under the hood. This tool will harvest falsy if the item is not present in the array.
    @item@The item in the array to be searched for.@;
    d has p t(item) {
        h this.indexOf(item) != -1
    }
    ;Get the first item of an array, or arr[0].;
    d first {
        h {
            h this[0]
        }
    }
    ;Get the last item of an array, or arr[arr.length - 1].;
    d last {
        h {
            h this[this.length - 1]
        }
    }
    ;Duplicate an array by appending all of its values to a new array. This copy is 'shallow', meaning that it will not create new reference points for objects and arrays within the original array. For a recursive copy tool, try Array.deepClone().;
    d clone p t() {
        d a p []
        for(d i p 0, i < this.length, i++) {
            a.push(this[i])
        }
        h a
    }
    ;Recursively duplicate an array, creating new references for every object and array within. The harvested result is a new array that is not tethered in any way to the original.;
    d deepClone p t() {
        # coming soon (requires type checking) #
        h yes
    }
    ;Insert a new value at any point in an array, and harvest the updated array. This method can be quite time-expensive, and users should consider transferring data to linked lists if they use Array.insert() extensively.
    @adding@The value to be added to the array.@
    @index@The index where the value should be inserted. For example, [0, 1, 2, 3].insert(4, 2) -> [0, 1, 4, 2, 3]. Range: {index <- Z | 0 <= index <= arr.length}.@;
    d insert p t(adding, index p 0) {
        d len p this.length
        if(len < index || index < 0) {
            throw "Invalid insert index argument! It should be in range (0 <-> length of array)."
        }
        for(d i p len, i > index, i--) {
            this[i] p this[i - 1]
        }
        this[index] p adding
        h this
    }
    ;Delete a value at any point in an array, and harvest the deleted value. This method can be quite time-expensive, and users should consider transferring data to linked lists if they use Array.delete() extensively.
    @index@The index where the value should be deleted. For example, [0, 1, 2, 3].delete(2) -> [0, 1, 3]. Range: {index <- Z | 0 <= index < arr.length}.@;
    d remove p t(index p 0) {
        d len p this.length
        if(index >= len || index < 0) {
            throw "Invalid remove index argument! It should be in range (0 <-> length of array - 1)."
        }
        d s p this[index]
        for(d i p index, i < len - 1, i++) {
            this[i] p this[i + 1]
        }
        this.delete(len - 1)
        h s
    }
    ;Arrange the contents of an array in reverse order, and harvest the updated array. Note: this method edits the original array rather than making a copy.;
    d reverse p t() {
        d len p this.length
        for(d i p 0, i < len / 2, i++) {
            d onI p this[i]
            d onO p this[len - i - 1]
            if(onO == onI) {
                continue
            }
            this[i] p onO
            this[len - 1] p onI
        }
        h this
    }
}